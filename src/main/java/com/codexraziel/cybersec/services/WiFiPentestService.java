package com.codexraziel.cybersec.services;

import com.codexraziel.cybersec.models.PentestConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

@Service
@Slf4j
public class WiFiPentestService {
    

    
    public CompletableFuture<Void> executeAttack(PentestConfig config, Consumer<String> outputCallback) {
        return CompletableFuture.runAsync(() -> {
            try {
                outputCallback.accept("[TARGET] Target: " + config.getTargetSSID());
                outputCallback.accept("[ATTACK] Attack Type: " + config.getAttackType());
                outputCallback.accept("[LIST] Wordlist: " + config.getWordlistPath());
                outputCallback.accept("[CONFIG] Threads: " + config.getThreadCount());
                
                switch (config.getAttackType()) {
                    case "Dictionary Attack":
                        executeDictionaryAttack(config, outputCallback);
                        break;
                    case "WPS PIN":
                        executeWPSAttack(config, outputCallback);
                        break;
                    default:
                        outputCallback.accept("[WARN] Unsupported attack type: " + config.getAttackType());
                }
                
            } catch (Exception e) {
                log.error("WiFi attack error", e);
                outputCallback.accept("[ERROR] Attack error: " + e.getMessage());
            }
        });
    }
    
    private void executeDictionaryAttack(PentestConfig config, Consumer<String> outputCallback) {
        outputCallback.accept("[START] Starting dictionary attack on " + config.getTargetSSID());
        
        if (tryAircrack(config, outputCallback)) {
            return;
        }
        
        if (tryHashcat(config, outputCallback)) {
            return;
        }
        
        outputCallback.accept("[WARN] Real attack tools not available");
        outputCallback.accept("[IDEA] Install aircrack-ng or hashcat for real attacks");
    }
    
    private void executeWPSAttack(PentestConfig config, Consumer<String> outputCallback) {
        outputCallback.accept("[SATELLITE] Starting WPS PIN attack on " + config.getTargetSSID());
        outputCallback.accept("[WARN] WPS attack tools not implemented");
        outputCallback.accept("[IDEA] Install reaver or bully for WPS attacks");
    }
    
    private boolean tryAircrack(PentestConfig config, Consumer<String> outputCallback) {
        try {
            ProcessBuilder pb = new ProcessBuilder("which", "aircrack-ng");
            if (pb.start().waitFor(5, TimeUnit.SECONDS) && pb.start().exitValue() == 0) {
                outputCallback.accept("[TOOL] Using aircrack-ng for attack");
                outputCallback.accept("[INFO] Target: " + config.getTargetSSID());
                outputCallback.accept("[FILE] Wordlist: " + config.getWordlistPath());
                return true;
            }
        } catch (Exception e) {
            log.debug("aircrack-ng not available: {}", e.getMessage());
        }
        return false;
    }
    
    private boolean tryHashcat(PentestConfig config, Consumer<String> outputCallback) {
        try {
            ProcessBuilder pb = new ProcessBuilder("which", "hashcat");
            if (pb.start().waitFor(5, TimeUnit.SECONDS) && pb.start().exitValue() == 0) {
                outputCallback.accept("[TOOL] Using hashcat for attack");
                return true;
            }
        } catch (Exception e) {
            log.debug("hashcat not available: {}", e.getMessage());
        }
        return false;
    }

    

    

    

}