package com.research.cybersec.services;

import com.research.cybersec.models.PentestConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

@Service
@Slf4j
public class WiFiPentestService {
    

    
    public CompletableFuture<Void> executeAttack(PentestConfig config, Consumer<String> outputCallback) {
        return CompletableFuture.runAsync(() -> {
            try {
                outputCallback.accept("[üéØ] Target: " + config.getTargetSSID());
                outputCallback.accept("[‚öîÔ∏è] Attack Type: " + config.getAttackType());
                outputCallback.accept("[üìã] Wordlist: " + config.getWordlistPath());
                outputCallback.accept("[üîß] Threads: " + config.getThreadCount());
                
                switch (config.getAttackType()) {
                    case "Dictionary Attack":
                        executeDictionaryAttack(config, outputCallback);
                        break;
                    case "WPS PIN":
                        executeWPSAttack(config, outputCallback);
                        break;
                    default:
                        outputCallback.accept("[‚ö†Ô∏è] Unsupported attack type: " + config.getAttackType());
                }
                
            } catch (Exception e) {
                log.error("WiFi attack error", e);
                outputCallback.accept("[‚ùå] Attack error: " + e.getMessage());
            }
        });
    }
    
    private void executeDictionaryAttack(PentestConfig config, Consumer<String> outputCallback) {
        outputCallback.accept("[üî•] Starting dictionary attack on " + config.getTargetSSID());
        
        if (tryAircrack(config, outputCallback)) {
            return;
        }
        
        if (tryHashcat(config, outputCallback)) {
            return;
        }
        
        outputCallback.accept("[‚ö†Ô∏è] Real attack tools not available");
        outputCallback.accept("[üí°] Install aircrack-ng or hashcat for real attacks");
    }
    
    private void executeWPSAttack(PentestConfig config, Consumer<String> outputCallback) {
        outputCallback.accept("[üì°] Starting WPS PIN attack on " + config.getTargetSSID());
        outputCallback.accept("[‚ö†Ô∏è] WPS attack tools not implemented");
        outputCallback.accept("[üí°] Install reaver or bully for WPS attacks");
    }
    
    private boolean tryAircrack(PentestConfig config, Consumer<String> outputCallback) {
        try {
            ProcessBuilder pb = new ProcessBuilder("which", "aircrack-ng");
            if (pb.start().waitFor(5, TimeUnit.SECONDS) && pb.start().exitValue() == 0) {
                outputCallback.accept("[üõ†Ô∏è] Using aircrack-ng for attack");
                outputCallback.accept("[üìù] Target: " + config.getTargetSSID());
                outputCallback.accept("[üìÅ] Wordlist: " + config.getWordlistPath());
                return true;
            }
        } catch (Exception e) {
            log.debug("aircrack-ng not available: {}", e.getMessage());
        }
        return false;
    }
    
    private boolean tryHashcat(PentestConfig config, Consumer<String> outputCallback) {
        try {
            ProcessBuilder pb = new ProcessBuilder("which", "hashcat");
            if (pb.start().waitFor(5, TimeUnit.SECONDS) && pb.start().exitValue() == 0) {
                outputCallback.accept("[üõ†Ô∏è] Using hashcat for attack");
                return true;
            }
        } catch (Exception e) {
            log.debug("hashcat not available: {}", e.getMessage());
        }
        return false;
    }

    

    

    

}